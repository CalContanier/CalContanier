
1. 正常容器功能(注册与实现分离)
    1. 类自动注入，解析构造或者方法参数列表
    2. 根据参数列表内容自动注入(注解 > 参数传入契约(临时契约) > 参数传入绑定(临时绑定关系) > 契约 > 绑定 > 创建 > 传入普通参数(变量映射) > 传入普通参数散列)
        1. 根据注解内容，从注解中解析参数并注入到参数变量中
        2. 根据类名从契约列表检查是否存在契约关系(容器契约及临时声明契约[待定])
            * 方法级契约(class->function()) > 类级契约(class) > 命名空间契约(namespace)
        3. 根据类名从已有的类绑定(bindings)关系中获取(容器绑定及临时声明绑定[待定])
        4. 若无绑定关系，则从容器尝试中自动构建该类实例
        5. 普通参数(无类型声明或者为基本数据类型)，从额外参数列表中自动注入，否则根据类型赋值默认值
        6. 接口类型参数(契约 > 传入参数子类判断)
            1. 查询契约关系
            2. 契约关系不存在则考虑从传入变量中解析子类,若无法解析则抛出异常
2. aop支持(使用注解实现)
    1. 类级别注解
        1. 声明类构建参数注入
        2. 全局函数注入
    2. 方法级别注解
        1. 参数注入
        2. 响应解析
    3. 属性级别注解
        1. 参数校验
        2. 参数数据提供
        3. 参数数据解析
3. 类缓存实现(生成在配置路径内)
    1. 缓存类扫描映射
        1. 缓存类的所有方法参数列表信息
        2. 缓存类注解信息
    2. 缓存契约绑定及关系列表
4. 多层级的容器获取支持
    1. 默认使用当前容器执行
    2. 驱动实现，可通过配置文件修改执行的容器
    3. 多容器驱动配合，可通过当前容器传递到下一层容器执行并响应(通过配置)
5. 支持框架容器(提供接口以实现框架容器执行)



## 依赖注入容器的高级功能
* 真实的dependency injection container会提供更多的特性，如
    * 自动绑定（Autowiring）或 自动解析（Automatic Resolution）
    * 注释解析器（Annotations）
    * 延迟注入（Lazy injection）

## 参考:
### 关于PSR规范
* [php-fig 容器规范](https://github.com/php-fig/container)
* [PSR-11译文](https://learnku.com/index.php/docs/psr/psr-11-container/1621)
### 开源项目参考
* [php-di](https://github.com/PHP-DI/PHP-DI)
* [silexphp/Pimple](https://github.com/silexphp/Pimple)
* [laravel-container](https://github.com/illuminate/container)

###
* [Reflection](https://www.php.net/manual/zh/class.reflection.php)
    * [ReflectionClass](https://www.php.net/manual/zh/class.reflectionclass.php)
    * [ReflectionObject](https://www.php.net/manual/zh/class.reflectionobject.php)
    * [ReflectionMethod](https://www.php.net/manual/zh/class.reflectionmethod.php)
    * [ReflectionFunction](https://www.php.net/manual/zh/class.reflectionfunction.php)
    * [ReflectionProperty](https://www.php.net/manual/zh/class.reflectionproperty.php)
* [phpunit](http://www.phpunit.cn/)
* IOC
* DI
* Composer

###




